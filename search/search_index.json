{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":":fontawesome-solid-journal-whills: Get started \u00b6 This package provides an expressive, minimal API around the Soap Client from Phpro , allowing you to quickly make outgoing SOAP requests to communicate with other web applications. Introduction \u00b6 It is using HTTPplug as handler with Guzzle as client. Some code is based/copied on/from Laravel Http wrapper . Thanks for inspiration :-) Installation \u00b6 Package Execute the following command to get the latest version of the package: composer require codedredd/laravel-soap Configuration Publish Configuration php artisan vendor:publish --provider \"CodeDredd\\Soap\\SoapServiceProvider\" Code generation feature If you also want to use the code generation feature you have to install following packages: composer require --dev laminas/laminas-code wsdl2phpgenerator/wsdl2phpgenerator","title":"Get started"},{"location":"#fontawesome-solid-journal-whills-get-started","text":"This package provides an expressive, minimal API around the Soap Client from Phpro , allowing you to quickly make outgoing SOAP requests to communicate with other web applications.","title":":fontawesome-solid-journal-whills: Get started"},{"location":"#introduction","text":"It is using HTTPplug as handler with Guzzle as client. Some code is based/copied on/from Laravel Http wrapper . Thanks for inspiration :-)","title":" Introduction"},{"location":"#installation","text":"Package Execute the following command to get the latest version of the package: composer require codedredd/laravel-soap Configuration Publish Configuration php artisan vendor:publish --provider \"CodeDredd\\Soap\\SoapServiceProvider\" Code generation feature If you also want to use the code generation feature you have to install following packages: composer require --dev laminas/laminas-code wsdl2phpgenerator/wsdl2phpgenerator","title":" Installation"},{"location":"commands/","text":":fontawesome-solid-journal-whills: Commands \u00b6 Yes this package comes with some artisan commands to make soap a bit more enjoyable. Requirements \u00b6 You need to install following package to use the code generation feature composer require --dev laminas/laminas-code wsdl2phpgenerator/wsdl2phpgenerator Overview \u00b6 Command Description php artisan soap:make:client Create a customized client by wsdl or config name php artisan soap:make:validation Create one or all validation classes by wsdl or config name Configuration \u00b6 If you have published the configuration file then you have some options for the code generation. Config Default Description code.path app_path('Soap') Define where the generated Code should be saved in your project code.namespace App\\\\Soap Define the namespace of the generated Code","title":"Commands"},{"location":"commands/#fontawesome-solid-journal-whills-commands","text":"Yes this package comes with some artisan commands to make soap a bit more enjoyable.","title":":fontawesome-solid-journal-whills: Commands"},{"location":"commands/#requirements","text":"You need to install following package to use the code generation feature composer require --dev laminas/laminas-code wsdl2phpgenerator/wsdl2phpgenerator","title":" Requirements"},{"location":"commands/#overview","text":"Command Description php artisan soap:make:client Create a customized client by wsdl or config name php artisan soap:make:validation Create one or all validation classes by wsdl or config name","title":" Overview"},{"location":"commands/#configuration","text":"If you have published the configuration file then you have some options for the code generation. Config Default Description code.path app_path('Soap') Define where the generated Code should be saved in your project code.namespace App\\\\Soap Define the namespace of the generated Code","title":" Configuration"},{"location":"testing/","text":":fontawesome-solid-journal-whills: Testing \u00b6 Many Laravel services provide functionality to help you easily and expressively write tests, and this SOAP wrapper is no exception. Faking \u00b6 Include use CodeDredd\\Soap\\Facades\\Soap in your testing class. The Soap facade's fake method allows you to instruct the SOAP client to return stubbed / dummy responses when requests are made. fake \u00b6 Intercepts request with possible given responses Method : function fake ( $callback = null ) Param : callable | array $callback Return : \\CodeDredd\\Soap\\SoapFactory Examples with Soap::response simple For returning empty 200 status code responses for every request, you may call the fake method with no arguments Soap :: fake (); with arguments You may pass an array to the fake method. The array's keys should represent ACTION patterns that you wish to fake and their associated responses. The * character may be used as a wildcard character. You may use the response method to construct stub / fake responses for these endpoints Soap :: fake ([ // Stub a JSON response for all Get_ actions... 'Get_*' => Soap :: response ([ 'foo' => 'bar' ], 200 , [ 'Headers' ]), // Stub a string response for Submit_User action 'Submit_User' => Soap :: response ( 'Hello World' , 200 , [ 'Headers' ]), ]); Difference between Laravel Http The difference between Laravels HTTP wrapper is the fact that actions which are not defined in fake are also faked with a default 200 response! overwrite default response Soap :: fake ([ // Stub a JSON response for all Get_ actions... 'Get_*' => Soap :: response ([ 'foo' => 'bar' ], 200 , [ 'Headers' ]), // Stub a string response for all other actions '*' => Soap :: response ( 'Hello World' , 200 , [ 'Headers' ]), ]); with callback If you require more complicated logic to determine what responses to return for certain endpoints, you may pass a callback to the fake method. This callback will receive an instance of CodeDredd\\Soap\\Client\\Request and should return a response instance: Soap :: fake ( function ( $request ) { return Soap :: response ( 'Hello World' , 200 ); }); Examples with Soap::sequence simple Sometimes you may need to specify that a single ACTION should return a series of fake responses in a specific order. You may accomplish this by using the Soap::sequence method to build the responses: Soap :: fake ([ // Stub a series of responses for Get_* actions... 'Get_*' => Soap :: sequence () -> push ( 'Hello World' ) -> push ([ 'foo' => 'bar' ]) -> pushStatus ( 404 ) ]); Throws exception if empty When all of the responses in a response sequence have been consumed, any further requests will cause the response sequence to throw an exception! wtih whenEmpty If you would like to specify a default response that should be returned when a sequence is empty, you may use the whenEmpty method Soap :: fake ([ // Stub a series of responses for Get_* actions... 'Get_*' => Soap :: sequence () -> push ( 'Hello World' ) -> push ([ 'foo' => 'bar' ]) -> whenEmpty ( Soap :: response ()) ]); response \u00b6 Create a new response instance for use during stubbing (for fake responses) Method : static function response ( $body = null , $status = 200 , $headers = []) Param : array | string | null $body Param : int $status Param : array $headers Return : \\GuzzleHttp\\Promise\\PromiseInterface When $body is string One important notice. Because a SOAP API doesn't return a single string value every response with only a string in the body is wrapped in an array with key response . [ 'response' => 'Hello World' ] sequence \u00b6 Get an invokable object that returns a sequence of responses in order for use during stubbing Method : function sequence ( array $responses = []) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence push \u00b6 Push a response to the sequence. Method : function push ( $body = '' , int $status = 200 , array $headers = []) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence pushResponse \u00b6 Push a response to the sequence. Method : function pushResponse ( $response ) Param : \\GuzzleHttp\\Promise\\PromiseInterface | \\Closure $response Return : \\CodeDredd\\Soap\\Client\\ResponseSequence pushStatus \u00b6 Push a response with the given status code to the sequence. Method : function pushStatus ( string $filePath , int $status = 200 , array $headers = []) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence dontFailWhenEmpty \u00b6 Make the sequence return a default response when it is empty. Method : function dontFailWhenEmpty () Return : \\CodeDredd\\Soap\\Client\\ResponseSequence whenEmpty \u00b6 Make the sequence return a custom default response when it is empty. Method : function whenEmpty ( $response ) Param : \\GuzzleHttp\\Promise\\PromiseInterface | \\Closure $response Return : \\CodeDredd\\Soap\\Client\\ResponseSequence pushFile \u00b6 Push response with the contents of a file as the body to the sequence. Method : function pushFile ( int $status = 200 , array $headers = []) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence fakeSequence \u00b6 If you would like to fake a sequence of responses but do not need to specify a specific ACTION pattern that should be faked, you may use the Soap::fakeSequence method. Register a response sequence for the given URL pattern. Method : function fakeSequence ( string $url = '*' ) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence Example Soap :: fakeSequence () -> push ( 'Hello World' ) -> whenEmpty ( Soap :: response ()); Tip fakeSequence has the same methods as Soap::response . So in most cases fakeSequence will be the better choice to fake response because its an easier and shorter way to define fake responses. Asserts \u00b6 When faking responses, you may occasionally wish to inspect the requests the client receives in order to make sure your application is sending the correct data or headers. assertSent \u00b6 Assert that a request / response pair was recorded matching a given truth test. Method : function assertSent ( callable $callback ) Return : void Examples simple Soap :: assertSent ( function ( $request ){ return $request -> action () === 'YourAction' }); with arguments Soap :: assertSent ( function ( $request ){ return $request -> action () === 'YourAction' && $request -> arguments () === [ 'argument' => 'value' ] }); full Soap :: fake (); Soap :: baseWsdl ( 'https://test/v1?wsdl' ) -> call ( 'YourAction' , [ 'argument' => 'value' ]); Soap :: assertSent ( function ( $request ){ return $request -> action () === 'YourAction' && $request -> arguments () === [ 'argument' => 'value' ] }); assertNotSent \u00b6 Assert that a request / response pair was not recorded matching a given truth test. Method : function assertNotSent ( callable $callback ) Return : void Examples simple Soap :: assertNotSent ( function ( $request ){ return $request -> action () === 'YourAction' }); with arguments Soap :: assertNotSent ( function ( $request ){ return $request -> action () === 'YourAction' && $request -> arguments () === [ 'argument' => 'value' ] }); full Soap :: fake (); Soap :: baseWsdl ( 'https://test/v1?wsdl' ) -> call ( 'YourAction' , [ 'argument' => 'value' ]); Soap :: assertNotSent ( function ( $request ){ return $request -> action () === 'YourAction' && $request -> arguments () === [ 'argument' => 'NotThisValue' ] }); assertActionCalled \u00b6 Assert that a given soap action is called with optional arguments. Method : function assertActionCalled ( string $action ) Return : void Examples simple Soap :: assertActionCalled ( 'YourAction' ); full Soap :: fake (); Soap :: baseWsdl ( 'https://test/v1?wsdl' ) -> call ( 'YourAction' ); Soap :: assertActionCalled ( 'YourAction' ); assertNothingSent \u00b6 Assert that no request / response pair was recorded. Method : function assertNothingSent () Return : void Examples simple Soap :: assertNothingSent (); full Soap :: fake (); Soap :: assertNothingSent (); assertSequencesAreEmpty \u00b6 Assert that every created response sequence is empty. Method : function assertSequencesAreEmpty () Return : void Examples simple Soap :: assertSequencesAreEmpty (); full Soap :: fake (); Soap :: assertSequencesAreEmpty (); assertSentCount \u00b6 Assert how many requests have been recorded. Method : function assertSentCount ( int $count ) Return : void Examples simple Soap :: assertSentCount ( 3 ); full Soap :: fake (); $client = Soap :: buildClient ( 'laravlel_soap' ); $response = $client -> call ( 'YourAction' ); $response2 = $client -> call ( 'YourOtherAction' ); Soap :: assertSentCount ( 2 ); assertSentInOrder \u00b6 Assert that the given request was sent in the given order. Method : function assertSentInOrder ( $callbacks ) Return : void","title":"Testing"},{"location":"testing/#fontawesome-solid-journal-whills-testing","text":"Many Laravel services provide functionality to help you easily and expressively write tests, and this SOAP wrapper is no exception.","title":":fontawesome-solid-journal-whills: Testing"},{"location":"testing/#faking","text":"Include use CodeDredd\\Soap\\Facades\\Soap in your testing class. The Soap facade's fake method allows you to instruct the SOAP client to return stubbed / dummy responses when requests are made.","title":" Faking"},{"location":"testing/#fake","text":"Intercepts request with possible given responses Method : function fake ( $callback = null ) Param : callable | array $callback Return : \\CodeDredd\\Soap\\SoapFactory Examples with Soap::response simple For returning empty 200 status code responses for every request, you may call the fake method with no arguments Soap :: fake (); with arguments You may pass an array to the fake method. The array's keys should represent ACTION patterns that you wish to fake and their associated responses. The * character may be used as a wildcard character. You may use the response method to construct stub / fake responses for these endpoints Soap :: fake ([ // Stub a JSON response for all Get_ actions... 'Get_*' => Soap :: response ([ 'foo' => 'bar' ], 200 , [ 'Headers' ]), // Stub a string response for Submit_User action 'Submit_User' => Soap :: response ( 'Hello World' , 200 , [ 'Headers' ]), ]); Difference between Laravel Http The difference between Laravels HTTP wrapper is the fact that actions which are not defined in fake are also faked with a default 200 response! overwrite default response Soap :: fake ([ // Stub a JSON response for all Get_ actions... 'Get_*' => Soap :: response ([ 'foo' => 'bar' ], 200 , [ 'Headers' ]), // Stub a string response for all other actions '*' => Soap :: response ( 'Hello World' , 200 , [ 'Headers' ]), ]); with callback If you require more complicated logic to determine what responses to return for certain endpoints, you may pass a callback to the fake method. This callback will receive an instance of CodeDredd\\Soap\\Client\\Request and should return a response instance: Soap :: fake ( function ( $request ) { return Soap :: response ( 'Hello World' , 200 ); }); Examples with Soap::sequence simple Sometimes you may need to specify that a single ACTION should return a series of fake responses in a specific order. You may accomplish this by using the Soap::sequence method to build the responses: Soap :: fake ([ // Stub a series of responses for Get_* actions... 'Get_*' => Soap :: sequence () -> push ( 'Hello World' ) -> push ([ 'foo' => 'bar' ]) -> pushStatus ( 404 ) ]); Throws exception if empty When all of the responses in a response sequence have been consumed, any further requests will cause the response sequence to throw an exception! wtih whenEmpty If you would like to specify a default response that should be returned when a sequence is empty, you may use the whenEmpty method Soap :: fake ([ // Stub a series of responses for Get_* actions... 'Get_*' => Soap :: sequence () -> push ( 'Hello World' ) -> push ([ 'foo' => 'bar' ]) -> whenEmpty ( Soap :: response ()) ]);","title":" fake"},{"location":"testing/#response","text":"Create a new response instance for use during stubbing (for fake responses) Method : static function response ( $body = null , $status = 200 , $headers = []) Param : array | string | null $body Param : int $status Param : array $headers Return : \\GuzzleHttp\\Promise\\PromiseInterface When $body is string One important notice. Because a SOAP API doesn't return a single string value every response with only a string in the body is wrapped in an array with key response . [ 'response' => 'Hello World' ]","title":" response"},{"location":"testing/#sequence","text":"Get an invokable object that returns a sequence of responses in order for use during stubbing Method : function sequence ( array $responses = []) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence","title":" sequence"},{"location":"testing/#push","text":"Push a response to the sequence. Method : function push ( $body = '' , int $status = 200 , array $headers = []) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence","title":" push"},{"location":"testing/#pushresponse","text":"Push a response to the sequence. Method : function pushResponse ( $response ) Param : \\GuzzleHttp\\Promise\\PromiseInterface | \\Closure $response Return : \\CodeDredd\\Soap\\Client\\ResponseSequence","title":" pushResponse"},{"location":"testing/#pushstatus","text":"Push a response with the given status code to the sequence. Method : function pushStatus ( string $filePath , int $status = 200 , array $headers = []) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence","title":" pushStatus"},{"location":"testing/#dontfailwhenempty","text":"Make the sequence return a default response when it is empty. Method : function dontFailWhenEmpty () Return : \\CodeDredd\\Soap\\Client\\ResponseSequence","title":" dontFailWhenEmpty"},{"location":"testing/#whenempty","text":"Make the sequence return a custom default response when it is empty. Method : function whenEmpty ( $response ) Param : \\GuzzleHttp\\Promise\\PromiseInterface | \\Closure $response Return : \\CodeDredd\\Soap\\Client\\ResponseSequence","title":" whenEmpty"},{"location":"testing/#pushfile","text":"Push response with the contents of a file as the body to the sequence. Method : function pushFile ( int $status = 200 , array $headers = []) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence","title":" pushFile"},{"location":"testing/#fakesequence","text":"If you would like to fake a sequence of responses but do not need to specify a specific ACTION pattern that should be faked, you may use the Soap::fakeSequence method. Register a response sequence for the given URL pattern. Method : function fakeSequence ( string $url = '*' ) Return : \\CodeDredd\\Soap\\Client\\ResponseSequence Example Soap :: fakeSequence () -> push ( 'Hello World' ) -> whenEmpty ( Soap :: response ()); Tip fakeSequence has the same methods as Soap::response . So in most cases fakeSequence will be the better choice to fake response because its an easier and shorter way to define fake responses.","title":" fakeSequence"},{"location":"testing/#asserts","text":"When faking responses, you may occasionally wish to inspect the requests the client receives in order to make sure your application is sending the correct data or headers.","title":" Asserts"},{"location":"testing/#assertsent","text":"Assert that a request / response pair was recorded matching a given truth test. Method : function assertSent ( callable $callback ) Return : void Examples simple Soap :: assertSent ( function ( $request ){ return $request -> action () === 'YourAction' }); with arguments Soap :: assertSent ( function ( $request ){ return $request -> action () === 'YourAction' && $request -> arguments () === [ 'argument' => 'value' ] }); full Soap :: fake (); Soap :: baseWsdl ( 'https://test/v1?wsdl' ) -> call ( 'YourAction' , [ 'argument' => 'value' ]); Soap :: assertSent ( function ( $request ){ return $request -> action () === 'YourAction' && $request -> arguments () === [ 'argument' => 'value' ] });","title":" assertSent"},{"location":"testing/#assertnotsent","text":"Assert that a request / response pair was not recorded matching a given truth test. Method : function assertNotSent ( callable $callback ) Return : void Examples simple Soap :: assertNotSent ( function ( $request ){ return $request -> action () === 'YourAction' }); with arguments Soap :: assertNotSent ( function ( $request ){ return $request -> action () === 'YourAction' && $request -> arguments () === [ 'argument' => 'value' ] }); full Soap :: fake (); Soap :: baseWsdl ( 'https://test/v1?wsdl' ) -> call ( 'YourAction' , [ 'argument' => 'value' ]); Soap :: assertNotSent ( function ( $request ){ return $request -> action () === 'YourAction' && $request -> arguments () === [ 'argument' => 'NotThisValue' ] });","title":" assertNotSent"},{"location":"testing/#assertactioncalled","text":"Assert that a given soap action is called with optional arguments. Method : function assertActionCalled ( string $action ) Return : void Examples simple Soap :: assertActionCalled ( 'YourAction' ); full Soap :: fake (); Soap :: baseWsdl ( 'https://test/v1?wsdl' ) -> call ( 'YourAction' ); Soap :: assertActionCalled ( 'YourAction' );","title":" assertActionCalled"},{"location":"testing/#assertnothingsent","text":"Assert that no request / response pair was recorded. Method : function assertNothingSent () Return : void Examples simple Soap :: assertNothingSent (); full Soap :: fake (); Soap :: assertNothingSent ();","title":" assertNothingSent"},{"location":"testing/#assertsequencesareempty","text":"Assert that every created response sequence is empty. Method : function assertSequencesAreEmpty () Return : void Examples simple Soap :: assertSequencesAreEmpty (); full Soap :: fake (); Soap :: assertSequencesAreEmpty ();","title":" assertSequencesAreEmpty"},{"location":"testing/#assertsentcount","text":"Assert how many requests have been recorded. Method : function assertSentCount ( int $count ) Return : void Examples simple Soap :: assertSentCount ( 3 ); full Soap :: fake (); $client = Soap :: buildClient ( 'laravlel_soap' ); $response = $client -> call ( 'YourAction' ); $response2 = $client -> call ( 'YourOtherAction' ); Soap :: assertSentCount ( 2 );","title":" assertSentCount"},{"location":"testing/#assertsentinorder","text":"Assert that the given request was sent in the given order. Method : function assertSentInOrder ( $callbacks ) Return : void","title":" assertSentInOrder"},{"location":"client/authentication/","text":"Authentication \u00b6 You may specify basic authentication credentials using the withBasicAuth method, respectively: // Basic authentication... $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->withBasicAuth('taylor@laravel.com', 'secret')->call(...); Web Service Security (WSS / WSSE) \u00b6 Internally it is using the wse-php package of robrichards which is a well known library that is used by many developers. It also supports not secured Wsse but with token: //Not secure $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->withWsse([ 'userTokenName' => 'username', 'userTokenPassword' => 'password', ])->call(...); //Secure $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->withWsse([ 'privateKeyFile' => 'path/to/privatekey.pem', 'publicKeyFile' => 'path/to/publickey.pyb', ])->call(...); You have following Wsse Options: 'userTokenName' : string 'userTokenPassword' : string 'privateKeyFile' : string 'publicKeyFile' : string 'serverCertificateFile' : string 'serverCertificateHasSubjectKeyIdentifier' : boolean 'userTokenDigest' : boolean 'digitalSignMethod' : string 'timestamp' : integer 'signAllHeaders' => : boolean Web Service Addressing (WSA) \u00b6 Like Wss/Wsse it uses the same package: $response = Soap::baseWsdl(...) ->withWsa() ->call(...) DHL Cis Authentication \u00b6 DHL uses his own authentication header $client = Soap::withCisDHLAuth('user', 'signature')","title":"authentication"},{"location":"client/authentication/#authentication","text":"You may specify basic authentication credentials using the withBasicAuth method, respectively: // Basic authentication... $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->withBasicAuth('taylor@laravel.com', 'secret')->call(...);","title":"Authentication"},{"location":"client/authentication/#web-service-security-wss-wsse","text":"Internally it is using the wse-php package of robrichards which is a well known library that is used by many developers. It also supports not secured Wsse but with token: //Not secure $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->withWsse([ 'userTokenName' => 'username', 'userTokenPassword' => 'password', ])->call(...); //Secure $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->withWsse([ 'privateKeyFile' => 'path/to/privatekey.pem', 'publicKeyFile' => 'path/to/publickey.pyb', ])->call(...); You have following Wsse Options: 'userTokenName' : string 'userTokenPassword' : string 'privateKeyFile' : string 'publicKeyFile' : string 'serverCertificateFile' : string 'serverCertificateHasSubjectKeyIdentifier' : boolean 'userTokenDigest' : boolean 'digitalSignMethod' : string 'timestamp' : integer 'signAllHeaders' => : boolean","title":"Web Service Security (WSS / WSSE)"},{"location":"client/authentication/#web-service-addressing-wsa","text":"Like Wss/Wsse it uses the same package: $response = Soap::baseWsdl(...) ->withWsa() ->call(...)","title":"Web Service Addressing (WSA)"},{"location":"client/authentication/#dhl-cis-authentication","text":"DHL uses his own authentication header $client = Soap::withCisDHLAuth('user', 'signature')","title":"DHL Cis Authentication"},{"location":"client/configuration/","text":"Configuration \u00b6 Soap Client Options \u00b6 You may specify additional Soap request options using the withOptions method. The withOptions method accepts an array of key / value pairs: $response = Soap::baseWsdl(...)->withOptions([ 'trace' => true, ])->call(...); By default this options are set by the Phpro package: 'trace' => true, 'exceptions' => true, 'keep_alive' => true, 'cache_wsdl' => WSDL_CACHE_DISK, // Avoid memory cache: this causes SegFaults from time to time. 'features' => SOAP_SINGLE_ELEMENT_ARRAYS, 'typemap' => new TypeConverterCollection([ new TypeConverter\\DateTimeTypeConverter(), new TypeConverter\\DateTypeConverter(), new TypeConverter\\DecimalTypeConverter(), new TypeConverter\\DoubleTypeConverter() ]), Headers \u00b6 Headers may be added to requests using the withHeaders method. This withHeaders method accepts an array of key / value pairs: $response = Soap::withHeaders([ 'X-First' => 'foo', 'X-Second' => 'bar' ])->baseWsdl('http://test.com'/v1?wsdl)->call('Get_Users'); Custom Client Class \u00b6 You are free to extend the SOAP client class used internally by this package, by defining your own class and extending the package client: use CodeDredd\\Soap\\SoapClient as BaseClient; class SoapClient extends BaseClient { // ... } After defining your class, you may instruct the factory to use your custom class. Typically, this will happen in the boot method of your application's App\\Providers\\AppServiceProvider class: use App\\Soap\\SoapClient; use CodeDredd\\Soap\\SoapFactory; public function boot() { SoapFactory::useClientClass(SoapClient::class); }","title":"configuration"},{"location":"client/configuration/#configuration","text":"","title":"Configuration"},{"location":"client/configuration/#soap-client-options","text":"You may specify additional Soap request options using the withOptions method. The withOptions method accepts an array of key / value pairs: $response = Soap::baseWsdl(...)->withOptions([ 'trace' => true, ])->call(...); By default this options are set by the Phpro package: 'trace' => true, 'exceptions' => true, 'keep_alive' => true, 'cache_wsdl' => WSDL_CACHE_DISK, // Avoid memory cache: this causes SegFaults from time to time. 'features' => SOAP_SINGLE_ELEMENT_ARRAYS, 'typemap' => new TypeConverterCollection([ new TypeConverter\\DateTimeTypeConverter(), new TypeConverter\\DateTypeConverter(), new TypeConverter\\DecimalTypeConverter(), new TypeConverter\\DoubleTypeConverter() ]),","title":"Soap Client Options"},{"location":"client/configuration/#headers","text":"Headers may be added to requests using the withHeaders method. This withHeaders method accepts an array of key / value pairs: $response = Soap::withHeaders([ 'X-First' => 'foo', 'X-Second' => 'bar' ])->baseWsdl('http://test.com'/v1?wsdl)->call('Get_Users');","title":"Headers"},{"location":"client/configuration/#custom-client-class","text":"You are free to extend the SOAP client class used internally by this package, by defining your own class and extending the package client: use CodeDredd\\Soap\\SoapClient as BaseClient; class SoapClient extends BaseClient { // ... } After defining your class, you may instruct the factory to use your custom class. Typically, this will happen in the boot method of your application's App\\Providers\\AppServiceProvider class: use App\\Soap\\SoapClient; use CodeDredd\\Soap\\SoapFactory; public function boot() { SoapFactory::useClientClass(SoapClient::class); }","title":"Custom Client Class"},{"location":"client/request/","text":"Request \u00b6 Simple call \u00b6 To make requests, you may use the call method or your soap action through magic __call . First, let's examine how to make a basic action request: use CodeDredd\\Soap\\Facades\\Soap; $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->call('Get_Users'); // Or via magic method call $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->Get_Users(); Call with arguments \u00b6 Of course, calling a action with arguments is also possible: $response = Soap::baseWsdl('http://test.com'/v1?wsdl) ->call('Submit_User', [ 'name' => 'Steve', 'role' => 'Network Administrator', ]); // Or via magic method call $response = Soap::baseWsdl('http://test.com'/v1?wsdl) ->Submit_User([ 'name' => 'Steve', 'role' => 'Network Administrator', ]);","title":"Request"},{"location":"client/request/#request","text":"","title":"Request"},{"location":"client/request/#simple-call","text":"To make requests, you may use the call method or your soap action through magic __call . First, let's examine how to make a basic action request: use CodeDredd\\Soap\\Facades\\Soap; $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->call('Get_Users'); // Or via magic method call $response = Soap::baseWsdl('http://test.com'/v1?wsdl)->Get_Users();","title":"Simple call"},{"location":"client/request/#call-with-arguments","text":"Of course, calling a action with arguments is also possible: $response = Soap::baseWsdl('http://test.com'/v1?wsdl) ->call('Submit_User', [ 'name' => 'Steve', 'role' => 'Network Administrator', ]); // Or via magic method call $response = Soap::baseWsdl('http://test.com'/v1?wsdl) ->Submit_User([ 'name' => 'Steve', 'role' => 'Network Administrator', ]);","title":"Call with arguments"},{"location":"client/response/","text":"Response \u00b6 Object \u00b6 The call method returns an instance of CodeDredd\\Soap\\Client\\Response , which provides a variety of methods that may be used to inspect the response: $response->body() : string; $response->json() : array; $response->status() : int; $response->ok() : bool; $response->successful() : bool; $response->serverError() : bool; $response->clientError() : bool; $response->onError(callable $callback): \\CodeDredd\\Soap\\Client\\Response; $response->collect(): \\Illuminate\\Support\\Collection; The CodeDredd\\Soap\\Client\\Response object also implements the PHP ArrayAccess interface, allowing you to access your response data directly on the response: return Soap::baseWsdl('http://test.com'/v1?wsdl)->call('Get_Users')['name']; Error Handling \u00b6 Unlike Guzzle's default behavior, this SOAP client wrapper does not throw exceptions on client or server errors ( 400 and 500 level responses from servers). You may determine if one of these errors was returned using the successful , clientError , or serverError methods: // Determine if the status code was >= 200 and < 300... $response->successful(); // Determine if the response has a 400 level status code... $response->clientError(); // Determine if the response has a 500 level status code... $response->serverError(); Throwing Exceptions \u00b6 If you have a response instance and would like to throw an instance of CodeDredd\\Soap\\Exceptions\\RequestException if the response is a client or server error, you may use the throw method: $response = Soap::baseWsdl(...)->call(...); // Throw an exception if a client or server error occurred... $response->throw(); return $response['user']['id']; The CodeDredd\\Soap\\Exceptions\\RequestException instance has a public $response property which will allow you to inspect the returned response. The throw method returns the response instance if no error occurred, allowing you to chain other operations onto the throw method: return Soap::baseWsdl(...) ->call(...) ->throw() ->json();","title":"Response"},{"location":"client/response/#response","text":"","title":"Response"},{"location":"client/response/#object","text":"The call method returns an instance of CodeDredd\\Soap\\Client\\Response , which provides a variety of methods that may be used to inspect the response: $response->body() : string; $response->json() : array; $response->status() : int; $response->ok() : bool; $response->successful() : bool; $response->serverError() : bool; $response->clientError() : bool; $response->onError(callable $callback): \\CodeDredd\\Soap\\Client\\Response; $response->collect(): \\Illuminate\\Support\\Collection; The CodeDredd\\Soap\\Client\\Response object also implements the PHP ArrayAccess interface, allowing you to access your response data directly on the response: return Soap::baseWsdl('http://test.com'/v1?wsdl)->call('Get_Users')['name'];","title":"Object"},{"location":"client/response/#error-handling","text":"Unlike Guzzle's default behavior, this SOAP client wrapper does not throw exceptions on client or server errors ( 400 and 500 level responses from servers). You may determine if one of these errors was returned using the successful , clientError , or serverError methods: // Determine if the status code was >= 200 and < 300... $response->successful(); // Determine if the response has a 400 level status code... $response->clientError(); // Determine if the response has a 500 level status code... $response->serverError();","title":"Error Handling"},{"location":"client/response/#throwing-exceptions","text":"If you have a response instance and would like to throw an instance of CodeDredd\\Soap\\Exceptions\\RequestException if the response is a client or server error, you may use the throw method: $response = Soap::baseWsdl(...)->call(...); // Throw an exception if a client or server error occurred... $response->throw(); return $response['user']['id']; The CodeDredd\\Soap\\Exceptions\\RequestException instance has a public $response property which will allow you to inspect the returned response. The throw method returns the response instance if no error occurred, allowing you to chain other operations onto the throw method: return Soap::baseWsdl(...) ->call(...) ->throw() ->json();","title":"Throwing Exceptions"}]}